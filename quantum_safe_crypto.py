# -*- coding: utf-8 -*-
"""quantum_safe_crypto.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qbYUtdsHE_vYzdxlBYc98gR8w4xjLCxH
"""

from oqs import Signature
import binascii

# Use Dilithium for digital signatures
SIG_ALG = 'Dilithium2'

print(f"\n=== Simulating Quantum-Safe Digital Signature between two IoT Devices ===")
print(f"Using algorithm: {SIG_ALG}")

# Simulate Device A (e.g., a sensor)
print("\n1. Device A: Generating its quantum-safe public/private key pair...")
sig_device_a = Signature(SIG_ALG)
public_key_device_a = sig_device_a.generate_keypair()
print(f"   Public Key length: {len(public_key_device_a)} bytes")

# Device A signs a message
message = b"Important sensor data: temperature=25.6C"
print(f"\n2. Device A: Signing message: {message.decode()}")
signature = sig_device_a.sign(message)
print(f"   Signature length: {len(signature)} bytes")

# Simulate Device B (e.g., a data collector)
print("\n3. Device B: Verifying the signature...")
sig_device_b = Signature(SIG_ALG)
is_valid = sig_device_b.verify(message, signature, public_key_device_a)

print("\n4. Verification:")
if is_valid:
    print("   SUCCESS! Signature is valid.")
    print("   The message is authentic and secure against quantum attacks!")
else:
    print("   ERROR! Signature verification failed. The message may be tampered with.")

# Cleanup
sig_device_a.free()
sig_device_b.free()